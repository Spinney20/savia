-- Custom SQL: extensions, triggers, validation functions, partial indexes
-- These are NOT auto-generated by Drizzle and must be maintained manually.

-- ============================================
-- Extensions
-- ============================================
CREATE EXTENSION IF NOT EXISTS "pgcrypto";
CREATE EXTENSION IF NOT EXISTS "btree_gist";

-- ============================================
-- Trigger: auto-update updated_at
-- ============================================
CREATE OR REPLACE FUNCTION fn_set_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Macro: create updated_at trigger on any table
CREATE OR REPLACE FUNCTION create_updated_at_trigger(table_name TEXT)
RETURNS VOID AS $$
BEGIN
    EXECUTE format(
        'CREATE TRIGGER trg_%s_updated_at
         BEFORE UPDATE ON %I
         FOR EACH ROW
         WHEN (OLD IS DISTINCT FROM NEW)
         EXECUTE FUNCTION fn_set_updated_at()',
        table_name, table_name
    );
END;
$$ LANGUAGE plpgsql;

-- Apply updated_at triggers
SELECT create_updated_at_trigger('companies');
SELECT create_updated_at_trigger('agencies');
SELECT create_updated_at_trigger('sites');
SELECT create_updated_at_trigger('employees');
SELECT create_updated_at_trigger('users');
SELECT create_updated_at_trigger('user_agency_assignments');
SELECT create_updated_at_trigger('employee_site_assignments');
SELECT create_updated_at_trigger('employee_documents');
SELECT create_updated_at_trigger('inspection_templates');
SELECT create_updated_at_trigger('inspection_template_versions');
SELECT create_updated_at_trigger('inspections');
SELECT create_updated_at_trigger('inspection_items');
SELECT create_updated_at_trigger('inspection_reviews');
SELECT create_updated_at_trigger('trainings');
SELECT create_updated_at_trigger('training_participants');
SELECT create_updated_at_trigger('training_materials');
SELECT create_updated_at_trigger('issue_categories');
SELECT create_updated_at_trigger('issue_reports');
SELECT create_updated_at_trigger('issue_assignments');
SELECT create_updated_at_trigger('issue_comments');
SELECT create_updated_at_trigger('app_settings');

-- ============================================
-- Trigger: audit logging
-- ============================================
CREATE OR REPLACE FUNCTION fn_audit_trigger()
RETURNS TRIGGER AS $$
DECLARE
    v_old_data JSONB;
    v_new_data JSONB;
    v_changed_fields JSONB;
    v_user_id TEXT;
    v_key TEXT;
    v_record_id TEXT;
BEGIN
    v_user_id := current_setting('app.current_user_id', true);

    IF TG_OP = 'DELETE' THEN
        v_record_id := OLD.id::TEXT;
        v_old_data := to_jsonb(OLD);
        v_new_data := NULL;
        v_changed_fields := NULL;
    ELSIF TG_OP = 'INSERT' THEN
        v_record_id := NEW.id::TEXT;
        v_old_data := NULL;
        v_new_data := to_jsonb(NEW);
        v_changed_fields := v_new_data;
    ELSIF TG_OP = 'UPDATE' THEN
        v_record_id := NEW.id::TEXT;
        v_old_data := to_jsonb(OLD);
        v_new_data := to_jsonb(NEW);

        v_changed_fields := '{}'::JSONB;
        FOR v_key IN SELECT jsonb_object_keys(v_new_data)
        LOOP
            IF v_new_data -> v_key IS DISTINCT FROM v_old_data -> v_key THEN
                v_changed_fields := v_changed_fields ||
                    jsonb_build_object(v_key, jsonb_build_object(
                        'old', v_old_data -> v_key,
                        'new', v_new_data -> v_key
                    ));
            END IF;
        END LOOP;

        IF v_changed_fields = '{}'::JSONB THEN
            RETURN NEW;
        END IF;
    END IF;

    -- Exclude sensitive fields
    v_old_data := v_old_data - 'cnp_encrypted' - 'cnp_hash' - 'password_hash';
    v_new_data := v_new_data - 'cnp_encrypted' - 'cnp_hash' - 'password_hash';

    INSERT INTO audit_logs (
        table_name, record_id, operation,
        old_values, new_values, changed_fields,
        performed_by, performed_at
    ) VALUES (
        TG_TABLE_NAME, v_record_id, TG_OP,
        v_old_data, v_new_data, v_changed_fields,
        v_user_id, NOW()
    );

    IF TG_OP = 'DELETE' THEN
        RETURN OLD;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Macro: create audit trigger on any table
CREATE OR REPLACE FUNCTION create_audit_trigger(table_name TEXT)
RETURNS VOID AS $$
BEGIN
    EXECUTE format(
        'CREATE TRIGGER trg_%s_audit
         AFTER INSERT OR UPDATE OR DELETE ON %I
         FOR EACH ROW
         EXECUTE FUNCTION fn_audit_trigger()',
        table_name, table_name
    );
END;
$$ LANGUAGE plpgsql;

-- Apply audit triggers on important tables
SELECT create_audit_trigger('companies');
SELECT create_audit_trigger('agencies');
SELECT create_audit_trigger('sites');
SELECT create_audit_trigger('employees');
SELECT create_audit_trigger('users');
SELECT create_audit_trigger('employee_documents');
SELECT create_audit_trigger('inspection_templates');
SELECT create_audit_trigger('inspections');
SELECT create_audit_trigger('issue_categories');
SELECT create_audit_trigger('issue_reports');
SELECT create_audit_trigger('issue_assignments');
SELECT create_audit_trigger('issue_comments');
SELECT create_audit_trigger('trainings');
SELECT create_audit_trigger('training_participants');

-- ============================================
-- Validation trigger: sites.company_id must match agency.company_id
-- ============================================
CREATE OR REPLACE FUNCTION fn_validate_site_company()
RETURNS TRIGGER AS $$
DECLARE
    v_agency_company_id BIGINT;
BEGIN
    SELECT company_id INTO v_agency_company_id
    FROM agencies WHERE id = NEW.agency_id;

    IF v_agency_company_id IS DISTINCT FROM NEW.company_id THEN
        RAISE EXCEPTION 'sites.company_id (%) must match agency.company_id (%)',
            NEW.company_id, v_agency_company_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_sites_validate_company
    BEFORE INSERT OR UPDATE ON sites
    FOR EACH ROW
    EXECUTE FUNCTION fn_validate_site_company();

-- ============================================
-- Validation trigger: employee_site_assignments user_id ↔ employee_id consistency
-- ============================================
CREATE OR REPLACE FUNCTION fn_validate_esa_user_employee()
RETURNS TRIGGER AS $$
DECLARE
    v_user_employee_id BIGINT;
BEGIN
    IF NEW.user_id IS NOT NULL THEN
        SELECT employee_id INTO v_user_employee_id
        FROM users WHERE id = NEW.user_id;

        IF v_user_employee_id IS DISTINCT FROM NEW.employee_id THEN
            RAISE EXCEPTION 'employee_site_assignments: user_id (%) points to employee_id (%), but assignment has employee_id (%)',
                NEW.user_id, v_user_employee_id, NEW.employee_id;
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_esa_validate_user_employee
    BEFORE INSERT OR UPDATE ON employee_site_assignments
    FOR EACH ROW
    EXECUTE FUNCTION fn_validate_esa_user_employee();

-- ============================================
-- Partial indexes (soft delete + frequently queried)
-- ============================================
CREATE INDEX IF NOT EXISTS idx_companies_deleted ON companies (id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_agencies_company ON agencies (company_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_agencies_deleted ON agencies (id) WHERE deleted_at IS NULL;
CREATE UNIQUE INDEX IF NOT EXISTS idx_agencies_code_company ON agencies (company_id, code) WHERE deleted_at IS NULL AND code IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_sites_agency ON sites (agency_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_sites_company ON sites (company_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_sites_status ON sites (status) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_sites_gps ON sites (latitude, longitude) WHERE deleted_at IS NULL AND latitude IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_employees_company ON employees (company_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_employees_status ON employees (status) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_employees_cnp_hash ON employees (cnp_hash) WHERE deleted_at IS NULL AND cnp_hash IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_employees_name ON employees (last_name, first_name) WHERE deleted_at IS NULL;

CREATE UNIQUE INDEX IF NOT EXISTS idx_users_email ON users (email) WHERE deleted_at IS NULL;
CREATE UNIQUE INDEX IF NOT EXISTS idx_users_employee ON users (employee_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_users_company ON users (company_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_users_role ON users (role) WHERE deleted_at IS NULL;

CREATE UNIQUE INDEX IF NOT EXISTS idx_uaa_active ON user_agency_assignments (user_id, agency_id)
    WHERE removed_at IS NULL AND deleted_at IS NULL;

CREATE INDEX IF NOT EXISTS idx_esa_employee ON employee_site_assignments (employee_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_esa_site ON employee_site_assignments (site_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_esa_active ON employee_site_assignments (employee_id, site_id)
    WHERE removed_at IS NULL AND deleted_at IS NULL;

CREATE INDEX IF NOT EXISTS idx_edocs_employee ON employee_documents (employee_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_edocs_expiry ON employee_documents (expiry_date)
    WHERE deleted_at IS NULL AND expiry_date IS NOT NULL AND expiry_notified = false;

CREATE INDEX IF NOT EXISTS idx_inspections_site ON inspections (site_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_inspections_status ON inspections (status) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_inspections_date ON inspections (completed_at DESC) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_inspections_site_status ON inspections (site_id, status) WHERE deleted_at IS NULL;

CREATE INDEX IF NOT EXISTS idx_trainings_site ON trainings (site_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_trainings_type ON trainings (training_type) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_trainings_site_type ON trainings (site_id, training_type) WHERE deleted_at IS NULL;

CREATE INDEX IF NOT EXISTS idx_issues_site ON issue_reports (site_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_issues_status ON issue_reports (status) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_issues_site_status ON issue_reports (site_id, status) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_issues_deadline ON issue_reports (deadline)
    WHERE deleted_at IS NULL AND deadline IS NOT NULL
    AND status NOT IN ('RESOLVED', 'VERIFIED', 'CLOSED') AND deadline_notified = false;
CREATE INDEX IF NOT EXISTS idx_issues_critical_open ON issue_reports (company_id, severity)
    WHERE deleted_at IS NULL AND severity = 'CRITICAL'
    AND status NOT IN ('RESOLVED', 'VERIFIED', 'CLOSED');

-- Attachment FK indexes
CREATE INDEX IF NOT EXISTS idx_attach_inspection ON attachments (inspection_id) WHERE inspection_id IS NOT NULL AND deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_attach_insp_item ON attachments (inspection_item_id) WHERE inspection_item_id IS NOT NULL AND deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_attach_training ON attachments (training_id) WHERE training_id IS NOT NULL AND deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_attach_issue ON attachments (issue_report_id) WHERE issue_report_id IS NOT NULL AND deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_attach_edoc ON attachments (employee_document_id) WHERE employee_document_id IS NOT NULL AND deleted_at IS NULL;

-- Notifications
CREATE INDEX IF NOT EXISTS idx_notif_recipient ON notifications (recipient_id, read_at) WHERE read_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_notif_pending ON notifications (push_status) WHERE push_status = 'PENDING';

-- Refresh tokens
CREATE INDEX IF NOT EXISTS idx_rt_user ON refresh_tokens (user_id) WHERE revoked_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_rt_hash ON refresh_tokens (token_hash) WHERE revoked_at IS NULL;

-- App settings
CREATE UNIQUE INDEX IF NOT EXISTS idx_settings_key ON app_settings (company_id, key);

-- Audit logs
CREATE INDEX IF NOT EXISTS idx_audit_table_date ON audit_logs (table_name, performed_at DESC);
CREATE INDEX IF NOT EXISTS idx_audit_record ON audit_logs (table_name, record_id);
CREATE INDEX IF NOT EXISTS idx_audit_user ON audit_logs (performed_by, performed_at DESC);

-- ============================================
-- Circular FK: inspection_templates.current_version_id → inspection_template_versions.id
-- ============================================
ALTER TABLE inspection_templates
    ADD CONSTRAINT fk_templates_current_version
    FOREIGN KEY (current_version_id) REFERENCES inspection_template_versions(id) ON DELETE SET NULL;
